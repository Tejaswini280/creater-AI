import OpenAI from 'openai';
import * as fs from 'fs';
import * as path from 'path';

// Real OpenAI API key provided by user - use environment variable with fallback
const OPENAI_API_KEY = process.env.OPENAI_API_KEY || "";

// Check if OpenAI API key is properly configured
const hasValidOpenAIKey = !!OPENAI_API_KEY && OPENAI_API_KEY.length > 20;

const openai = hasValidOpenAIKey ? new OpenAI({
  apiKey: OPENAI_API_KEY,
}) : null;

const config = {
  hasKey: !!OPENAI_API_KEY && OPENAI_API_KEY.length > 20,
  uploadDir: path.join(process.cwd(), 'uploads'),
};

if (hasValidOpenAIKey) {
  console.log('‚úÖ Media AI Service - OpenAI initialized with real API key');
} else {
  console.warn('‚ö†Ô∏è Media AI Service - OpenAI API key not configured or invalid');
}

export class MediaAIService {
  
  // Generate thumbnails using DALL-E 3
  static async generateThumbnail(prompt: string, options?: {
    style?: string;
    aspectRatio?: string;
    size?: '1024x1024' | '1792x1024' | '1024x1792';
    quality?: 'standard' | 'hd';
  }): Promise<{
    imageUrl: string;
    revisedPrompt: string;
    metadata: {
      model: string;
      size: string;
      quality: string;
      style: string;
    };
  }> {
    console.log('Thumbnail generation - API key check:', { hasValidOpenAIKey, openaiClient: !!openai });
    
    // Helper to build a high-quality fallback thumbnail URL that works without OpenAI
    const buildFallback = () => {
      const size = options?.size || "1792x1024";
      // Use a reliable placeholder image provider (HTTPS allowed by helmet config)
      const bg = "6D28D9"; // indigo-700
      const fg = "FFFFFF"; // white
      // Only render the title text; do not include style or descriptive phrases in the image text
      const cleanTitle = (prompt || "AI Thumbnail").toString().replace(/\s*\(.*?\)\s*/g, '').trim();
      const text = encodeURIComponent(cleanTitle.slice(0, 70));
      // Use a more reliable placeholder service that doesn't use timestamps that expire
      const imageUrl = `https://placehold.co/${size}/${bg}/${fg}.png?text=${text}&font=roboto`;
      return {
        imageUrl,
        revisedPrompt: `${prompt} (fallback thumbnail)`,
        metadata: {
          model: "fallback",
          size,
          quality: options?.quality || "hd",
          style: options?.style || "professional",
        },
      } as const;
    };

    // If OpenAI key is unavailable, return a graceful fallback instead of throwing
    if (!hasValidOpenAIKey || !openai) {
      console.warn('‚ö†Ô∏è OpenAI API not available for thumbnail generation, returning fallback');
      return buildFallback();
    }

    try {
      // Enhance prompt with style and aspect ratio
      // Ensure we only pass the title as the base prompt; style is appended as an instruction, not part of the text
      let enhancedPrompt = `${(prompt || '').toString().replace(/\s*\(.*?\)\s*/g, '').trim()}`;
      if (options?.style) {
        enhancedPrompt += `, apply ${options.style} styling (do not write style text)`;
      }
      if (options?.aspectRatio) {
        enhancedPrompt += `, ${options.aspectRatio} aspect ratio`;
      }
      
      // Add professional thumbnail enhancements
      enhancedPrompt += ', professional thumbnail design, high quality, eye-catching, optimized for social media, text overlay contains only the title';
      
      const response = await openai!.images.generate({
        model: "dall-e-3",
        prompt: enhancedPrompt,
        n: 1,
        size: options?.size || "1792x1024",
        quality: options?.quality || "hd",
        response_format: "url",
      });

      if (!response.data || response.data.length === 0) {
        console.warn('No image generated by OpenAI, using fallback');
        return buildFallback();
      }

      const imageUrl = response.data[0].url || '';
      const revisedPrompt = response.data[0].revised_prompt || enhancedPrompt;

      return {
        imageUrl,
        revisedPrompt,
        metadata: {
          model: "dall-e-3",
          size: options?.size || "1792x1024",
          quality: options?.quality || "hd",
          style: options?.style || "professional",
        },
      };
    } catch (error: any) {
      console.error('DALL-E 3 thumbnail generation error:', error);
      // Regardless of the error, return a fallback so UX remains smooth
      return buildFallback();
    }
  }

  // Generate voiceovers using TTS-HD
  static async generateVoiceover(text: string, options?: {
    voice?: 'alloy' | 'echo' | 'fable' | 'onyx' | 'nova' | 'shimmer';
    speed?: number;
    format?: 'mp3' | 'opus' | 'aac' | 'flac';
    quality?: 'standard' | 'hd';
  }): Promise<{
    audioUrl: string;
    duration: number;
    metadata: {
      model: string;
      voice: string;
      speed: number;
      format: string;
      quality: string;
    };
  }> {
    console.log('Voiceover generation - API key check:', { hasValidOpenAIKey, openaiClient: !!openai });
    console.log('Voiceover generation - input text:', { text, type: typeof text, length: text?.length });
    
    // Validate text parameter
    if (!text || typeof text !== 'string') {
      console.error('Invalid text parameter:', { text, type: typeof text });
      throw new Error('Text parameter is required and must be a string');
    }
    
    // Check if we have a valid API key
    if (!hasValidOpenAIKey || !openai) {
      console.warn('OpenAI API not available, using fallback voiceover generation');
      
      // Return fallback voiceover data
      return {
        audioUrl: 'https://www.soundjay.com/misc/sounds/bell-ringing-05.wav', // Sample audio URL
        duration: Math.ceil(text.length / 150), // Rough estimate: 150 characters per second
        metadata: {
          model: "fallback",
          voice: options?.voice || "alloy",
          speed: options?.speed || 1.0,
          format: options?.format || "mp3",
          quality: options?.quality || "hd",
        },
      };
    }

    try {
      // Validate text length (TTS-HD has limits)
      if (text.length > 4096) {
        throw new Error('Text too long. Maximum 4096 characters allowed.');
      }

      const response = await openai!.audio.speech.create({
        model: "tts-1-hd",
        voice: options?.voice || "alloy",
        input: text,
        response_format: options?.format || "mp3",
        speed: options?.speed || 1.0,
      });

      // Convert response to buffer and save to file
      const buffer = Buffer.from(await response.arrayBuffer());
      const fileName = `voiceover_${Date.now()}.${options?.format || 'mp3'}`;
      const filePath = path.join(process.cwd(), 'uploads', 'voiceovers', fileName);
      
      // Ensure directory exists
      const dir = path.dirname(filePath);
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }
      
      fs.writeFileSync(filePath, buffer);
      
      // Calculate approximate duration (rough estimate)
      const duration = Math.ceil(text.length / 150); // ~150 characters per second
      
      return {
        audioUrl: `/uploads/voiceovers/${fileName}`,
        duration,
        metadata: {
          model: "tts-1-hd",
          voice: options?.voice || "alloy",
          speed: options?.speed || 1.0,
          format: options?.format || "mp3",
          quality: "hd",
        },
      };
    } catch (error: any) {
      console.error('TTS-HD voiceover generation error:', error);
      
      // Handle billing limit specifically
      if (error.message && error.message.includes('billing')) {
        console.error('üí∞ Billing limit reached for TTS-HD');
        throw new Error('OpenAI billing limit reached - please check your account');
      }
      
      throw new Error(`Failed to generate voiceover: ${error}`);
    }
  }

  // Generate multiple thumbnail variations
  static async generateThumbnailVariations(prompt: string, count: number = 3): Promise<{
    thumbnails: string[];
    variations: Array<{
      imageUrl: string;
      revisedPrompt: string;
      style: string;
    }>;
  }> {
    try {
      const styles = ['modern', 'vintage', 'minimalist', 'bold', 'elegant'];
      const variations = [];

      for (let i = 0; i < Math.min(count, styles.length); i++) {
        const variation = await this.generateThumbnail(prompt, {
          style: styles[i],
          aspectRatio: "16:9",
          quality: "hd",
        });

        variations.push({
          imageUrl: variation.imageUrl,
          revisedPrompt: variation.revisedPrompt,
          style: styles[i],
        });
      }

      // Extract just the image URLs for the thumbnails array
      const thumbnails = variations.map(v => v.imageUrl);

      return { 
        thumbnails,
        variations 
      };
    } catch (error) {
      console.error('Thumbnail variations generation error:', error);
      
      throw new Error(`Failed to generate thumbnail variations: ${error}`);
    }
  }

  // Generate voiceover with different voices
  static async generateVoiceoverVariations(text: string, voices: string[] = ['alloy', 'echo', 'nova']): Promise<{
    variations: Array<{
      audioUrl: string;
      voice: string;
      duration: number;
    }>;
  }> {
    try {
      const variations = [];

      for (const voice of voices) {
        const variation = await this.generateVoiceover(text, {
          voice: voice as any,
          speed: 1.0,
          format: "mp3",
        });

        variations.push({
          audioUrl: variation.audioUrl,
          voice,
          duration: variation.duration,
        });
      }

      return { variations };
    } catch (error) {
      console.error('Voiceover variations generation error:', error);
      throw new Error(`Failed to generate voiceover variations: ${error}`);
    }
  }

  // Batch generate thumbnails for multiple prompts
  static async batchGenerateThumbnails(prompts: string[]): Promise<{
    results: Array<{
      prompt: string;
      imageUrl: string;
      revisedPrompt: string;
    }>;
  }> {
    try {
      const results = [];

      for (const prompt of prompts) {
        const result = await this.generateThumbnail(prompt, {
          style: "professional",
          aspectRatio: "16:9",
        });

        results.push({
          prompt,
          imageUrl: result.imageUrl,
          revisedPrompt: result.revisedPrompt,
        });
      }

      return { results };
    } catch (error) {
      console.error('Batch thumbnail generation error:', error);
      throw new Error(`Failed to batch generate thumbnails: ${error}`);
    }
  }

  // Optimize thumbnail for specific platform
  static async generatePlatformOptimizedThumbnail(
    prompt: string,
    platform: 'youtube' | 'instagram' | 'tiktok' | 'linkedin'
  ): Promise<{
    imageUrl: string;
    revisedPrompt: string;
    platform: string;
    recommendations: string[];
  }> {
    try {
      const platformConfigs = {
        youtube: {
          aspectRatio: "16:9" as const,
          style: "bold, high contrast, text overlay friendly",
          size: "1792x1024" as const,
        },
        instagram: {
          aspectRatio: "1:1" as const,
          style: "aesthetic, trendy, visually appealing",
          size: "1024x1024" as const,
        },
        tiktok: {
          aspectRatio: "9:16" as const,
          style: "dynamic, energetic, mobile-optimized",
          size: "1024x1792" as const,
        },
        linkedin: {
          aspectRatio: "16:9" as const,
          style: "professional, corporate, business-focused",
          size: "1792x1024" as const,
        },
      };

      const config = platformConfigs[platform];
      const enhancedPrompt = `${prompt}, ${config.style}, optimized for ${platform}`;

      const result = await this.generateThumbnail(enhancedPrompt, {
        aspectRatio: config.aspectRatio,
        size: config.size,
        quality: "hd",
      });

      const recommendations = [
        `Use ${config.aspectRatio} aspect ratio for ${platform}`,
        `Apply ${config.style} styling`,
        `Ensure text is readable on mobile devices`,
        `Use high contrast colors for better visibility`,
      ];

      return {
        imageUrl: result.imageUrl,
        revisedPrompt: result.revisedPrompt,
        platform,
        recommendations,
      };
    } catch (error) {
      console.error('Platform optimized thumbnail generation error:', error);
      throw new Error(`Failed to generate platform optimized thumbnail: ${error}`);
    }
  }
} 